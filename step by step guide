As a parent trying to keep my kids safe online, I realized that app-based parental controls weren’t enough. Kids could bypass them, reset devices, or simply use different browsers. I needed something more robust — a network-level solution that every device would respect, with no way around it. This is the story of how I built a complete parental control gateway using Ubuntu Server and Pi-hole. It sits between my home network and the internet, filtering everything before it reaches any device.

Understanding the Architecture
Here’s what we’re building: Internet flows to your ISP Modem, then to an Ubuntu Server Gateway running Pi-hole, then to your WiFi Router operating as an access point, and finally to your devices. The Ubuntu Server acts as a router forwarding traffic between your home and the internet, a DNS filter using Pi-hole to block inappropriate content, a DHCP server automatically configuring all devices, and a firewall preventing bypass attempts. Every device must go through this gateway, and there’s no bypassing it.

What You’ll Need
For hardware, you’ll need a small PC with two ethernet ports or a Raspberry Pi 4 with a USB ethernet adapter, with minimum specifications of 2GB RAM and 16GB storage. You’ll also need your existing WiFi router which we’ll reconfigure to use as an access point, and three ethernet cables to connect everything together. For software, everything is free and includes Ubuntu Server 22.04 LTS, Pi-hole, and standard Linux networking tools. Plan for about 4–6 hours for the initial setup, though you can take breaks and spread this across a weekend.

Part 1: Installing and Configuring Ubuntu Server
Start by downloading Ubuntu Server from ubuntu.com and create a bootable USB drive using Balena Etcher, which is a free tool available for Windows, Mac, and Linux. Insert the USB drive into your gateway hardware, boot from it, and follow the installation wizard. During installation, make sure to install the OpenSSH server which allows you to manage the gateway remotely, skip any additional software snaps for now since we’ll install what we need manually, and create a strong admin password that you’ll remember or store in a password manager.

After installation completes and the system reboots, log in and identify your network interfaces by running the command “ip addr show” which displays all network interfaces on your system. You’ll see two physical ethernet interfaces, typically named something like eth0 and eth1. In my setup, eth0 is the built-in port that connects to my ISP modem (the WAN side), and eth1 is the USB ethernet adapter that connects to my home network (the LAN side).

Now we need to configure these interfaces using Netplan, which is Ubuntu’s network configuration system. Edit the Netplan configuration file by running “sudo nano /etc/netplan/00-installer-config.yaml” and configure it so that eth0 uses DHCP to get an IP address from your modem automatically, while eth1 has a static IP address of 192.168.1.1/24 which becomes your gateway address. The configuration should look like this: under network, set version to 2, renderer to networkd, and under ethernets, configure eth0 with dhcp4 set to true for the WAN connection to your modem, and configure eth1 with addresses set to 192.168.1.1/24 and dhcp4 set to false for your LAN connection. Save the file and apply the configuration by running “sudo netplan apply” which immediately applies your network settings.

Next, we need to enable IP forwarding so that your Ubuntu Server can route traffic between the two network interfaces. By default, Linux doesn’t forward packets between interfaces as a security feature, but we explicitly want this machine to be a router. Edit the system configuration by running “sudo nano /etc/sysctl.conf” and look for the line that says “net.ipv4.ip_forward=1” which is probably commented out with a hash symbol at the beginning. Remove the hash symbol to uncomment the line, then save and exit. Apply this change immediately without rebooting by running “sudo sysctl -p” which reloads the system configuration and enables IP forwarding right away.

Now we need to set up NAT, which stands for Network Address Translation. NAT is necessary because your home network uses private IP addresses in the 192.168.1.x range which aren’t routable on the internet, so outgoing packets need to be rewritten to appear as if they’re coming from your public IP address. First, install iptables-persistent by running “sudo apt update” followed by “sudo apt install iptables-persistent -y” which ensures your firewall rules persist across reboots. Create the NAT rule by running “sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE” which enables masquerading on the WAN interface, effectively translating private IPs to your public IP. Then allow forwarding from LAN to WAN by running “sudo iptables -A FORWARD -i eth1 -o eth0 -j ACCEPT” which permits traffic from your home network to the internet. Finally, allow established connections to return by running “sudo iptables -A FORWARD -i eth0 -o eth1 -m state — state RELATED,ESTABLISHED -j ACCEPT” which permits reply traffic from the internet back to your devices. Save all these rules permanently by running “sudo netfilter-persistent save” which writes the rules to files that are loaded at boot time.

At this point, you should test basic routing to make sure everything is working before moving on to Pi-hole. From another computer on your network, manually configure its network settings to use 192.168.1.1 as the gateway and temporarily use 8.8.8.8 for DNS. Try pinging google.com and you should get successful responses, confirming that your Ubuntu Server is properly routing traffic to the internet and back.

Part 2: Installing Pi-hole for DNS Filtering
Press enter or click to view image in full size

Now we’re ready to install Pi-hole, which is the heart of our parental control system. Pi-hole acts as a DNS server that checks every domain request against blocklists and blocks inappropriate content by returning a dead-end address. Run the automated Pi-hole installer by executing “curl -sSL https://install.pi-hole.net | bash” which downloads and runs the installation script. The installer presents an interactive wizard that guides you through the configuration process.

During the installation, you’ll be asked to make several choices. For the upstream DNS provider, choose Cloudflare at 1.1.1.1 because it’s fast, reliable, and privacy-focused. For blocklists, accept the defaults for now since we’ll add specialized parental control lists later. When asked about the web interface, definitely select yes because it makes managing Pi-hole much easier through a user-friendly dashboard. For the web server, select yes to install lighttpd which is a lightweight web server that hosts the admin interface. Enable query logging when asked because it’s essential for monitoring what your kids are accessing and what’s being blocked. For privacy mode, select “Show everything” because for parental controls we want full visibility into network activity. Finally, make sure the installer uses eth1 as the interface since that’s your LAN side.

When the installation completes, the wizard displays an admin password on the screen. Write this down immediately or take a screenshot because you’ll need it to access the Pi-hole admin interface. You can change this password later if needed, but don’t lose it now.

Access the Pi-hole web interface by opening a browser and navigating to “http://192.168.1.1/admin" and log in with the password you just saved. You’ll see the dashboard which shows total queries processed, queries blocked, percentage blocked, and other statistics. Now we need to add family-friendly blocklists that specifically target inappropriate content rather than just ads and trackers. Click on “Group Management” in the left sidebar, then click “Adlists” to see the list management page. Add these blocklists one at a time by pasting each URL into the address field and clicking add: “https://blocklistproject.github.io/Lists/porn.txt" for pornography and adult content, “https://blocklistproject.github.io/Lists/gambling.txt" for gambling sites, “https://blocklistproject.github.io/Lists/drugs.txt" for drug-related content, “https://raw.githubusercontent.com/StevenBlack/hosts/master/alternates/fakenews-gambling-porn/hosts" for a comprehensive list covering multiple categories, and “https://blocklistproject.github.io/Lists/malware.txt" for malware and phishing protection.

After adding all these blocklists, you need to tell Pi-hole to download and process them by clicking “Tools” in the left sidebar, then clicking “Update Gravity” which is Pi-hole’s term for rebuilding its domain database. Click the blue “Update” button and wait for the process to complete, which takes a few minutes since we’re processing millions of domains. When finished, you’ll see statistics showing how many domains are now blocked, which should be well over 2 million with the lists we’ve added.

Test that Pi-hole blocking is working correctly by opening a terminal on your test computer and running “nslookup doubleclick.net 192.168.1.1” which queries Pi-hole for a domain that should be blocked. You should see the server listed as 192.168.1.1 and the address returned as 0.0.0.0, which is Pi-hole’s way of blocking a domain. When a browser tries to connect to 0.0.0.0, the connection fails and the site doesn’t load, effectively blocking access without any scary warning messages that kids might screenshot or bypass.

Part 3: Setting Up DHCP for Automatic Configuration
Currently, we’re manually configuring network settings on test devices, but that’s not sustainable for an entire household. We need DHCP, which stands for Dynamic Host Configuration Protocol, to automatically configure every device with the correct settings including gateway and DNS. When a device connects to your network, DHCP automatically provides it with an IP address, subnet mask, gateway address, and DNS server address, ensuring every device uses Pi-hole for DNS filtering without any manual configuration required.

Before enabling DHCP on our gateway, we must disable it on your existing router because having two DHCP servers on the same network causes conflicts and chaos. Log into your WiFi router’s admin interface by navigating to its IP address in a web browser, which is commonly 192.168.0.1, 192.168.1.1, or 10.0.0.1, using the admin credentials that are typically on a sticker on the router or in its manual. Look for DHCP settings which are usually under Network Settings, Advanced Settings, or LAN Settings, and disable the DHCP server completely, then save the settings. While you’re in the router settings, also look for an option called “Access Point Mode” or “Bridge Mode” and enable it if available, which turns your router into essentially a wireless access point that just provides WiFi connectivity without trying to route traffic or manage the network.

Make sure your router is connected correctly to your Ubuntu Server gateway by plugging an ethernet cable from your Ubuntu Server’s eth1 LAN interface to one of your router’s LAN ports, not the WAN or Internet port. The router’s WAN port should remain empty because we’re using the router only for its switch and WiFi capabilities, not its routing functions.

Now enable Pi-hole’s built-in DHCP server by opening the Pi-hole web interface at “http://192.168.1.1/admin" and logging in. Click “Settings” in the left sidebar, then click the “DHCP” tab. Check the box that says “DHCP server enabled” which reveals additional configuration options below. Configure the DHCP range by setting “From” to 192.168.1.100 and “To” to 192.168.1.250, which gives us 151 IP addresses to assign to devices and leaves addresses 2 through 99 available for devices that need static IP assignments like printers or servers. In the “Router (gateway) IP address” field, enter 192.168.1.1 which tells devices that our Ubuntu Server is the gateway to the internet. Set the lease time to 24 hours, which is a good balance between devices maintaining consistent IPs and allowing changes to propagate reasonably quickly. Optionally, you can set a domain name like “home.local” for your local network, which allows you to access devices by name instead of just IP addresses. Click the “Save” button at the bottom to activate Pi-hole’s DHCP server.

Restart Pi-hole’s services to ensure everything is working properly by opening a terminal on your Ubuntu Server and running “pihole restartdns” which restarts both DNS and DHCP services. Now test DHCP with a real device by taking your test laptop and resetting its network settings to obtain an IP address automatically via DHCP instead of using the manual static configuration we set up earlier. After reconnecting to the network, check what settings your device received by running “ip addr show” to see the IP address, “ip route show” to see the gateway, and “cat /etc/resolv.conf” to see the DNS server. You should see an IP address in the range 192.168.1.100–250, gateway set to 192.168.1.1, and DNS server set to 192.168.1.1, which means your device is now automatically configured to use the gateway and Pi-hole for DNS filtering.

Test that internet access and DNS filtering both work correctly through the DHCP-configured settings by running “ping google.com” which should succeed, followed by “nslookup doubleclick.net” which should show the server as 192.168.1.1 and return 0.0.0.0 as the address, confirming that blocking is working. At this point, you can start connecting your family’s devices one by one including smartphones, tablets, smart TVs, gaming consoles, and IoT devices, and each device should automatically receive the correct configuration via DHCP and be immediately protected by Pi-hole filtering.

Part 4: Configuring Linux Clients Properly
Most devices on your network will now automatically use Pi-hole for DNS thanks to DHCP, but Linux computers running systemd-resolved often require special configuration to properly respect network DNS settings. Modern Linux distributions like Ubuntu, Debian, and Fedora use a service called systemd-resolved which runs a local DNS resolver on the computer itself at IP address 127.0.0.53. When your Linux computer receives DNS settings from DHCP telling it to use 192.168.1.1, systemd-resolved intercepts this and sets up the resolv.conf file to point to 127.0.0.53 instead, meaning your Linux computer is essentially ignoring the network-provided DNS server. This is a significant problem for parental controls because DNS queries don’t go through Pi-hole, filtering is bypassed, and your parental controls don’t work on that Linux device.

To fix this, we need to disable systemd-resolved and configure the Linux computer to use Pi-hole directly. Log into your Linux computer and check the current DNS configuration by running “cat /etc/resolv.conf” which will likely show “nameserver 127.0.0.53” confirming that systemd-resolved is intercepting DNS queries. Stop the systemd-resolved service by running “sudo systemctl stop systemd-resolved” which immediately stops the service, then disable it at boot by running “sudo systemctl disable systemd-resolved” which prevents it from starting automatically when the computer boots.

The resolv.conf file is usually a symbolic link pointing to a file managed by systemd-resolved, so we need to remove this symlink and create a real file. Remove the symbolic link by running “sudo rm /etc/resolv.conf” which deletes the link, then create a new resolv.conf file by running “echo ‘nameserver 192.168.1.1’ | sudo tee /etc/resolv.conf” which creates the file with exactly the content we need.

Test that DNS queries now go through Pi-hole by running “nslookup google.com” which should show the server as 192.168.1.1, confirming queries are going through Pi-hole. Test that blocking works by running “nslookup doubleclick.net” which should return 0.0.0.0 as the address, meaning Pi-hole blocked the domain.

However, there’s still a problem because after rebooting your Linux computer, the configuration might revert. NetworkManager or another network management service might rewrite the resolv.conf file even with systemd-resolved disabled. We need to prevent any service from modifying resolv.conf by making the file immutable at the filesystem level. Run “sudo chattr +i /etc/resolv.conf” which sets the immutable attribute, preventing any modifications to the file even by root processes. Verify the file is now immutable by running “lsattr /etc/resolv.conf” which should show an “i” in the attributes, indicating the file is immutable.

Become a member
For additional security, tell NetworkManager to stop managing DNS entirely by editing the NetworkManager configuration with “sudo nano /etc/NetworkManager/NetworkManager.conf” and adding “dns=none” under the main section. Save the file and restart NetworkManager by running “sudo systemctl restart NetworkManager” which applies the changes. Reboot your Linux computer to verify everything persists by running “sudo reboot” and after it restarts, check that resolv.conf still contains “nameserver 192.168.1.1” and that DNS queries still go through Pi-hole with blocking working correctly. The configuration is now permanent and will survive reboots, network changes, and system updates.

Part 5: Advanced Parental Controls
Now that our basic infrastructure is working with the gateway routing traffic, Pi-hole filtering DNS, and DHCP configuring devices automatically, we can implement more sophisticated parental control features. Pi-hole’s Groups feature is incredibly powerful for parental controls because it allows you to create different filtering profiles and assign them to different devices or users. You can have heavy filtering for young children, moderate filtering for teenagers, and light filtering for adults, all managed from a single system.

Plan your group structure based on your family’s needs before creating groups in Pi-hole. I created a Default group with heavy filtering for young children that blocks adult content, violence, drugs, gambling, social media, and gaming; a Teens group with moderate filtering that blocks adult content, violence, drugs, and gambling but allows social media and some gaming; a Parents group with light filtering that only blocks malware and phishing but allows everything else; and a Guests group with medium filtering for visitors that blocks adult content and illegal activities but allows general browsing.

Create these groups in Pi-hole by logging into the web interface, clicking “Group Management” in the left sidebar, then clicking “Groups”. Click “Add a new group” and create each group with an appropriate name and description. Now assign different blocklists to each group by going to “Group Management” then “Adlists” where you’ll see all the blocklists we added earlier, each with checkboxes in the Group assignment column. For adult content blocklists, check Default, Teens, and Guests but uncheck Parents so that adults have access while kids don’t. For gambling blocklists, use the same assignment. For drugs blocklists, check Default and Teens but uncheck Parents and Guests. For malware and phishing blocklists, check all groups because everyone needs protection from malware. If you added social media blocklists, check only Default so that only the youngest kids are blocked from social media. After making these assignments, update Gravity by going to “Tools” then “Update Gravity” and clicking “Update” so the changes take effect.

To assign devices to groups, you first need to identify them by their MAC address, which is a unique hardware identifier for each network device. In Pi-hole, go to “Settings” then the “DHCP” tab and scroll down to “DHCP leases currently being handed out” where you’ll see a list of all devices that have received IP addresses from our DHCP server. For each device, note the hostname if available, IP address, and MAC address which looks like AA:BB:CC:DD:EE:FF. You’ll need to identify which devices belong to which family members by looking at hostnames, temporarily disconnecting devices to see which disappears from the list, or looking up MAC address vendor prefixes online.

Add specific devices to Pi-hole by going to “Group Management” then “Clients” and clicking “Add a new client” for each device you want to configure. For example, add your young child’s iPad by entering their IP address or leaving it blank, giving it a client name like “Lily’s iPad”, adding a comment like “8-year-old’s device”, and clicking “Add”. Do the same for your teenager’s laptop, your phone, and all other important devices in your home. After adding devices, assign each to the appropriate group by checking the corresponding box in the Group assignment column. For young children’s devices, check only Default to get the heaviest filtering. For teenagers’ devices, check only Teens for moderate filtering. For parent devices, check only Parents for light filtering.

Test that group-based filtering is working correctly by trying to access different domains from different devices. From a child’s device in the Default group, run “nslookup facebook.com” which should return 0.0.0.0 if you blocked social media for that group. From a teenager’s device in the Teens group, the same command should return a real IP address if Teens are allowed social media, confirming that different devices are getting different filtering rules.

Implement time-based restrictions to block certain content during specific times, such as blocking social media during homework hours or preventing gaming late at night. Pi-hole doesn’t have built-in scheduling, but we can implement this using scripts and cron jobs. First, find the database IDs of your social media blocklists by running “sudo sqlite3 /etc/pihole/gravity.db ‘SELECT id, address, comment FROM adlist;’” on your Ubuntu Server, which shows all your blocklists with their ID numbers. Note the IDs of social media and gaming lists, which you’ll use in scripts.

Create a script to enable social media blocking by running “sudo nano /usr/local/bin/disable-social-media.sh” and adding a script that updates the Pi-hole database to enable the social media blocklist and reloads Pi-hole with “sqlite3 /etc/pihole/gravity.db ‘UPDATE adlist SET enabled = 1 WHERE id = 5;’” followed by “pihole restartdns reload-lists”, using your actual blocklist ID instead of 5. Create the opposite script to disable blocking by running “sudo nano /usr/local/bin/enable-social-media.sh” with similar content but setting enabled to 0 instead of 1. Make both scripts executable by running “sudo chmod +x /usr/local/bin/disable-social-media.sh” and the same for the enable script.

Schedule these scripts to run automatically at specific times using cron by editing the root crontab with “sudo crontab -e” and adding entries like “0 15 * * 1–5 /usr/local/bin/disable-social-media.sh” to block social media at 3 PM on weekdays during homework hours, and “0 18 * * 1–5 /usr/local/bin/enable-social-media.sh” to allow it again at 6 PM after homework time. You can add similar rules for bedtime restrictions, morning allowances, and weekend schedules.

Enforce safe search on search engines to filter out adult content from search results by using DNS records to redirect regular search engine domains to their safe search versions. In Pi-hole, click “Local DNS” then “DNS Records” and add CNAME records: for Google safe search, set domain “www.google.com" to target “forcesafesearch.google.com”; for YouTube restricted mode, set “www.youtube.com" to “restrictmoderate.youtube.com”; for Bing safe search, set “www.bing.com" to “strict.bing.com”. Now when anyone on your network visits these search engines, they’re automatically redirected to the safe search versions, and searching for potentially inappropriate content returns only filtered, appropriate results.

Block VPN services to prevent tech-savvy kids from bypassing parental controls by adding VPN-blocking blocklists to Pi-hole. Go to “Group Management” then “Adlists” and add “https://raw.githubusercontent.com/hagezi/dns-blocklists/main/domains/vpn.txt" and “https://blocklistproject.github.io/Lists/vpn.txt", then assign these lists to all groups, especially Default and Teens groups, and update Gravity to apply the changes. Additionally, block common VPN ports at the firewall level by running commands on your Ubuntu Server to drop traffic on ports 1194 for OpenVPN, 51820 for WireGuard, and 500 and 4500 for IPSec, then save the rules with “sudo netfilter-persistent save”.

Redirect all DNS queries to Pi-hole regardless of what DNS server a device tries to use, preventing tech-savvy users from manually configuring their devices to use alternative DNS servers like 8.8.8.8 to bypass filtering. Run iptables commands on your Ubuntu Server to intercept and redirect all DNS queries on port 53 to Pi-hole at 192.168.1.1, then save the rules. This transparent redirection means that even if someone configures their device to use a different DNS server, all DNS traffic is redirected to Pi-hole, making bypass attempts much more difficult.

Part 6: Monitoring and Maintenance
A parental control system is only effective if it’s properly maintained and monitored, so establish routines for checking system health and adjusting settings as needed. The Pi-hole dashboard at “http://192.168.1.1/admin" is your primary monitoring tool and shows total DNS queries processed, queries blocked, percentage blocked, and when blocklists were last updated. Monitor the “Queries last 24 hours” graph for unusual spikes which might indicate unusual activity or attempted bypasses, and check the “Top Blocked Domains” list to see what kids are trying to access most frequently.

Use the Query Log, which you can access by clicking “Query Log” in the left sidebar, to see detailed information about every DNS request including the time it occurred, which domain was requested, which device made the request, and whether it was allowed or blocked. Filter the log to view queries from specific devices by clicking device names, view only blocked queries by looking for red “Blocked” status entries, or search for specific domains using the search box at the top.

Establish a weekly update routine every Sunday evening that includes updating blocklists by running “pihole -g” on your Ubuntu Server, updating Pi-hole itself with “pihole -up”, and updating the Ubuntu Server system with “sudo apt update && sudo apt upgrade -y”. Review the Pi-hole dashboard for the week’s activity, check if any legitimate sites were incorrectly blocked and need to be whitelisted, and look for patterns in query logs that might indicate kids testing boundaries or discovering new concerning domains.

Create automatic backups to ensure you can recover if something goes wrong by creating a backup script that uses Pi-hole’s built-in backup feature with “pihole -a -t”, backs up important system files including network configuration and custom scripts, and saves iptables rules with “sudo iptables-save”. Schedule this backup script to run weekly using cron, and configure it to keep only the last 30 days of backups to save disk space.

Monitor system health regularly by checking CPU usage with “top”, memory usage with “free -h”, and disk space with “df -h” to ensure your gateway has adequate resources. Review system logs periodically with “sudo journalctl -n 100” to look for errors or warnings, and specifically check Pi-hole logs with “sudo journalctl -u pihole-FTL -n 50” for any DNS service issues.

Set up email alerts for critical events by installing mail utilities with “sudo apt install mailutils ssmtp -y”, configuring SSMTP with your email credentials, and creating scripts that check for concerning conditions like specific high-risk domains being queried, excessive DNS queries from a single device indicating possible attack or misconfiguration, or new unknown devices appearing on the network. Schedule these alert scripts to run hourly using cron so you’re notified quickly of any issues.

Troubleshooting Common Issues
If devices can’t access the internet at all, verify that IP forwarding is enabled by running “cat /proc/sys/net/ipv4/ip_forward” which should return 1, and check that NAT rules are in place by running “sudo iptables -t nat -L” which should show the MASQUERADE rule. If legitimate sites are being incorrectly blocked, go to Pi-hole’s whitelist by clicking “Whitelist” in the left sidebar, add the domain that should be allowed, and update Gravity to apply the change.

If internet seems slow after setting up the gateway, check that Pi-hole’s database isn’t too large by running “du -h /etc/pihole/pihole-FTL.db” and if it’s over 1GB, reduce the retention period by editing “/etc/pihole/pihole-FTL.conf” and setting “MAXDBDAYS=7” to keep only seven days of query history. If a Linux device is bypassing filtering, verify that “/etc/resolv.conf” points to 192.168.1.1 and check the immutable flag with “lsattr /etc/resolv.conf” to ensure it can’t be changed.

If devices are getting IP addresses in unexpected ranges or not getting addresses at all, verify that your old router’s DHCP is definitely disabled and check Pi-hole’s DHCP settings to ensure the range and gateway are configured correctly. If Pi-hole stops responding, restart its services with “pihole restartdns” and check the status with “pihole status” to see if any components are failing.

Results After Six Months of Use
After running this system for six months, I’ve seen significant positive changes in my family’s relationship with technology. For my kids, there are fewer arguments about screen time because automated controls reduce negotiations, better sleep patterns since blocking social media after 9 PM has helped with bedtime routines, more focused homework time as gaming and social media blocks during homework hours actually work, and increased awareness about online safety because we regularly discuss what gets blocked and why.

For me as a parent, there’s genuine peace of mind knowing that inappropriate content is blocked at the network level where kids can’t easily bypass it, better insights into what my kids are interested in through Pi-hole logs which opens up conversation opportunities, reduced stress because I’m not constantly checking individual devices, and flexibility to easily adjust restrictions as kids mature and demonstrate responsibility.

There have been unexpected benefits beyond parental controls, including faster internet because blocking ads and trackers improved overall bandwidth, protection from malware as the system has blocked several malicious domains automatically, reduced data usage with about 30 percent less bandwidth consumption from blocking ads and trackers, and automatic guest network safety since visitors’ devices are automatically protected without any configuration needed.

This system has proven that network-level parental controls combined with open communication create a safer digital environment where kids can explore, learn, and grow with appropriate boundaries, and I highly encourage other parents facing similar challenges to consider building their own gateway using these same tools and principles.
